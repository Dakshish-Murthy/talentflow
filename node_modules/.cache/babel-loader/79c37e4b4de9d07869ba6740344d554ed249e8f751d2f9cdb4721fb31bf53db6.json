{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useCallback } from 'react';\nimport { useAppDispatch, useAppSelector } from './redux';\nimport { fetchCandidates, updateCandidate, addCandidateNote, fetchCandidateTimeline, setFilters, setPagination, setCurrentCandidate, optimisticStageChange, rollbackStageChange } from '../store/slices/candidatesSlice';\nimport { candidatesService } from '../services/candidatesService';\nexport const useCandidates = () => {\n  _s();\n  const dispatch = useAppDispatch();\n  const {\n    candidates,\n    currentCandidate,\n    loading,\n    error,\n    pagination,\n    filters\n  } = useAppSelector(state => state.candidates);\n  const loadCandidates = useCallback(params => {\n    return dispatch(fetchCandidates(params));\n  }, [dispatch]);\n\n  // Add the missing loadCandidate function\n  const loadCandidate = useCallback(async candidateId => {\n    try {\n      const candidate = await candidatesService.getCandidateById(candidateId);\n      dispatch(setCurrentCandidate(candidate));\n      return candidate;\n    } catch (error) {\n      console.error('Failed to load candidate:', error);\n      throw error;\n    }\n  }, [dispatch]);\n  const updateCandidateStage = useCallback(async (candidateId, newStage) => {\n    const candidate = candidates.find(c => c.id === candidateId);\n    if (!candidate) return;\n    const oldStage = candidate.stage;\n\n    // Optimistic update\n    dispatch(optimisticStageChange({\n      candidateId,\n      newStage\n    }));\n    try {\n      await dispatch(updateCandidate({\n        id: candidateId,\n        updates: {\n          stage: newStage\n        }\n      })).unwrap();\n    } catch (error) {\n      // Rollback on failure\n      dispatch(rollbackStageChange({\n        candidateId,\n        oldStage\n      }));\n      throw error;\n    }\n  }, [dispatch, candidates]);\n  const addNote = useCallback((candidateId, note) => {\n    return dispatch(addCandidateNote({\n      candidateId,\n      note\n    }));\n  }, [dispatch]);\n  const createCandidate = useCallback(async candidateData => {\n    const response = await candidatesService.createCandidate(candidateData);\n    return response;\n  }, []);\n  const loadTimeline = useCallback(candidateId => {\n    return dispatch(fetchCandidateTimeline(candidateId));\n  }, [dispatch]);\n  const updateFilters = useCallback(newFilters => {\n    dispatch(setFilters(newFilters));\n  }, [dispatch]);\n  const updatePagination = useCallback(newPagination => {\n    dispatch(setPagination(newPagination));\n  }, [dispatch]);\n  const selectCandidate = useCallback(candidate => {\n    dispatch(setCurrentCandidate(candidate));\n  }, [dispatch]);\n  return {\n    // State\n    candidates,\n    currentCandidate,\n    loading,\n    error,\n    pagination,\n    filters,\n    // Actions\n    loadCandidates,\n    loadCandidate,\n    // Add the missing function\n    updateCandidateStage,\n    addNote,\n    createCandidate,\n    loadTimeline,\n    updateFilters,\n    updatePagination,\n    selectCandidate\n  };\n};\n_s(useCandidates, \"1K6ilbdsPCt09ifVuMA791WQMEg=\", false, function () {\n  return [useAppDispatch, useAppSelector];\n});","map":{"version":3,"names":["useCallback","useAppDispatch","useAppSelector","fetchCandidates","updateCandidate","addCandidateNote","fetchCandidateTimeline","setFilters","setPagination","setCurrentCandidate","optimisticStageChange","rollbackStageChange","candidatesService","useCandidates","_s","dispatch","candidates","currentCandidate","loading","error","pagination","filters","state","loadCandidates","params","loadCandidate","candidateId","candidate","getCandidateById","console","updateCandidateStage","newStage","find","c","id","oldStage","stage","updates","unwrap","addNote","note","createCandidate","candidateData","response","loadTimeline","updateFilters","newFilters","updatePagination","newPagination","selectCandidate"],"sources":["C:/Users/Dakshish/talentflow/src/hooks/useCandidates.ts"],"sourcesContent":["import { useCallback } from 'react';\r\nimport { useAppDispatch, useAppSelector } from './redux';\r\nimport {\r\n  fetchCandidates,\r\n  updateCandidate,\r\n  addCandidateNote,\r\n  fetchCandidateTimeline,\r\n  setFilters,\r\n  setPagination,\r\n  setCurrentCandidate,\r\n  optimisticStageChange,\r\n  rollbackStageChange,\r\n} from '../store/slices/candidatesSlice';\r\nimport { Candidate, Note } from '../types';\r\nimport { candidatesService } from '../services/candidatesService';\r\n\r\nexport const useCandidates = () => {\r\n  const dispatch = useAppDispatch();\r\n  const { candidates, currentCandidate, loading, error, pagination, filters } = useAppSelector(\r\n    (state) => state.candidates\r\n  );\r\n\r\n  const loadCandidates = useCallback((params?: any) => {\r\n    return dispatch(fetchCandidates(params));\r\n  }, [dispatch]);\r\n\r\n  // Add the missing loadCandidate function\r\n  const loadCandidate = useCallback(async (candidateId: string) => {\r\n    try {\r\n      const candidate = await candidatesService.getCandidateById(candidateId);\r\n      dispatch(setCurrentCandidate(candidate));\r\n      return candidate;\r\n    } catch (error) {\r\n      console.error('Failed to load candidate:', error);\r\n      throw error;\r\n    }\r\n  }, [dispatch]);\r\n\r\n  const updateCandidateStage = useCallback(async (candidateId: string, newStage: Candidate['stage']) => {\r\n    const candidate = candidates.find(c => c.id === candidateId);\r\n    if (!candidate) return;\r\n\r\n    const oldStage = candidate.stage;\r\n    \r\n    // Optimistic update\r\n    dispatch(optimisticStageChange({ candidateId, newStage }));\r\n    \r\n    try {\r\n      await dispatch(updateCandidate({ id: candidateId, updates: { stage: newStage } })).unwrap();\r\n    } catch (error) {\r\n      // Rollback on failure\r\n      dispatch(rollbackStageChange({ candidateId, oldStage }));\r\n      throw error;\r\n    }\r\n  }, [dispatch, candidates]);\r\n\r\n  const addNote = useCallback((candidateId: string, note: Omit<Note, 'id' | 'createdAt'>) => {\r\n    return dispatch(addCandidateNote({ candidateId, note }));\r\n  }, [dispatch]);\r\n\r\n  const createCandidate = useCallback(async (candidateData: Omit<Candidate, 'id' | 'appliedDate' | 'notes'>) => {\r\n    const response = await candidatesService.createCandidate(candidateData);\r\n    return response;\r\n  }, []);\r\n\r\n  const loadTimeline = useCallback((candidateId: string) => {\r\n    return dispatch(fetchCandidateTimeline(candidateId));\r\n  }, [dispatch]);\r\n\r\n  const updateFilters = useCallback((newFilters: Partial<typeof filters>) => {\r\n    dispatch(setFilters(newFilters));\r\n  }, [dispatch]);\r\n\r\n  const updatePagination = useCallback((newPagination: Partial<typeof pagination>) => {\r\n    dispatch(setPagination(newPagination));\r\n  }, [dispatch]);\r\n\r\n  const selectCandidate = useCallback((candidate: Candidate | null) => {\r\n    dispatch(setCurrentCandidate(candidate));\r\n  }, [dispatch]);\r\n\r\n  return {\r\n    // State\r\n    candidates,\r\n    currentCandidate,\r\n    loading,\r\n    error,\r\n    pagination,\r\n    filters,\r\n    \r\n    // Actions\r\n    loadCandidates,\r\n    loadCandidate, // Add the missing function\r\n    updateCandidateStage,\r\n    addNote,\r\n    createCandidate,\r\n    loadTimeline,\r\n    updateFilters,\r\n    updatePagination,\r\n    selectCandidate,\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}