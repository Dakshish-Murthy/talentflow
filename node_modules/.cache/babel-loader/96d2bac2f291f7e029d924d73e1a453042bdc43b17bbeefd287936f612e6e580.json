{"ast":null,"code":"import { db } from './database';\nimport { seedDatabase } from '../data/seed';\nconst API_BASE = '/api';\nconst simulateLatency = (min = 200, max = 1200) => new Promise(resolve => setTimeout(resolve, Math.random() * (max - min) + min));\nconst simulateError = (errorRate = 0.1) => Math.random() < errorRate;\n\n// Initialize database with seed data\nconst initializeDatabase = async () => {\n  try {\n    const jobCount = await db.jobs.count();\n    if (jobCount === 0) {\n      console.log('Initializing database with seed data...');\n      await seedDatabase();\n    }\n  } catch (error) {\n    console.error('Failed to initialize database:', error);\n  }\n};\nexport const api = {\n  // Jobs endpoints\n  async getJobs(params = {}) {\n    await simulateLatency();\n    await initializeDatabase();\n    if (simulateError(0.05)) throw new Error('Failed to fetch jobs');\n    try {\n      let jobs = await db.jobs.orderBy('order').toArray();\n\n      // Apply filters\n      if (params.search) {\n        const searchLower = params.search.toLowerCase();\n        jobs = jobs.filter(job => {\n          var _job$company, _job$tags;\n          return job.title.toLowerCase().includes(searchLower) || ((_job$company = job.company) === null || _job$company === void 0 ? void 0 : _job$company.toLowerCase().includes(searchLower)) || ((_job$tags = job.tags) === null || _job$tags === void 0 ? void 0 : _job$tags.some(tag => tag.toLowerCase().includes(searchLower)));\n        });\n      }\n      if (params.status) {\n        jobs = jobs.filter(job => job.status === params.status);\n      }\n\n      // Apply pagination\n      const page = params.page || 1;\n      const pageSize = params.pageSize || 10;\n      const startIndex = (page - 1) * pageSize;\n      const endIndex = startIndex + pageSize;\n      const paginatedJobs = jobs.slice(startIndex, endIndex);\n      return {\n        data: paginatedJobs,\n        total: jobs.length,\n        page,\n        pageSize,\n        totalPages: Math.ceil(jobs.length / pageSize)\n      };\n    } catch (error) {\n      console.error('Error fetching jobs:', error);\n      throw new Error('Failed to fetch jobs');\n    }\n  },\n  async createJob(jobData) {\n    await simulateLatency();\n    await initializeDatabase();\n    if (simulateError(0.1)) throw new Error('Failed to create job');\n    try {\n      // Get the highest order to place new job at the top\n      const jobs = await db.jobs.orderBy('order').toArray();\n      const maxOrder = jobs.length > 0 ? Math.max(...jobs.map(j => j.order)) : 0;\n      const newJob = {\n        ...jobData,\n        id: `job-${Date.now()}`,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        order: maxOrder + 1\n      };\n      await db.jobs.add(newJob);\n      return newJob;\n    } catch (error) {\n      console.error('Error creating job:', error);\n      throw new Error('Failed to create job');\n    }\n  },\n  async updateJob(id, updates) {\n    await simulateLatency();\n    if (simulateError(0.1)) throw new Error('Failed to update job');\n    try {\n      const existingJob = await db.jobs.get(id);\n      if (!existingJob) throw new Error('Job not found');\n      const updatedJob = {\n        ...existingJob,\n        ...updates,\n        updatedAt: new Date()\n      };\n      await db.jobs.update(id, updatedJob);\n      return updatedJob;\n    } catch (error) {\n      console.error('Error updating job:', error);\n      throw new Error('Failed to update job');\n    }\n  },\n  async reorderJobs(fromOrder, toOrder) {\n    await simulateLatency();\n    if (simulateError(0.1)) throw new Error('Reorder failed');\n    try {\n      const jobs = await db.jobs.orderBy('order').toArray();\n      const fromIndex = jobs.findIndex(job => job.order === fromOrder);\n      const toIndex = jobs.findIndex(job => job.order === toOrder);\n      if (fromIndex === -1 || toIndex === -1) {\n        throw new Error('Invalid reorder operation');\n      }\n      const [movedJob] = jobs.splice(fromIndex, 1);\n      jobs.splice(toIndex, 0, movedJob);\n\n      // Update orders in transaction\n      await db.transaction('rw', db.jobs, async () => {\n        for (let i = 0; i < jobs.length; i++) {\n          await db.jobs.update(jobs[i].id, {\n            order: i + 1\n          });\n        }\n      });\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error reordering jobs:', error);\n      throw new Error('Failed to reorder jobs');\n    }\n  },\n  // Candidates endpoints\n  async getCandidates(params = {}) {\n    await simulateLatency();\n    await initializeDatabase();\n    if (simulateError(0.05)) throw new Error('Failed to fetch candidates');\n    try {\n      let candidates = await db.candidates.toArray();\n\n      // Apply filters\n      if (params.search) {\n        const searchLower = params.search.toLowerCase();\n        candidates = candidates.filter(candidate => candidate.name.toLowerCase().includes(searchLower) || candidate.email.toLowerCase().includes(searchLower));\n      }\n      if (params.stage) {\n        candidates = candidates.filter(candidate => candidate.stage === params.stage);\n      }\n\n      // Apply pagination\n      const page = params.page || 1;\n      const pageSize = params.pageSize || 50;\n      const startIndex = (page - 1) * pageSize;\n      const endIndex = startIndex + pageSize;\n      const paginatedCandidates = candidates.slice(startIndex, endIndex);\n      return {\n        data: paginatedCandidates,\n        total: candidates.length,\n        page,\n        pageSize\n      };\n    } catch (error) {\n      console.error('Error fetching candidates:', error);\n      throw new Error('Failed to fetch candidates');\n    }\n  },\n  async createCandidate(candidateData) {\n    await simulateLatency();\n    if (simulateError(0.1)) throw new Error('Failed to create candidate');\n    try {\n      const newCandidate = {\n        ...candidateData,\n        id: `candidate-${Date.now()}`,\n        appliedDate: new Date(),\n        notes: []\n      };\n      await db.candidates.add(newCandidate);\n      return newCandidate;\n    } catch (error) {\n      console.error('Error creating candidate:', error);\n      throw new Error('Failed to create candidate');\n    }\n  },\n  async updateCandidate(id, updates) {\n    await simulateLatency();\n    if (simulateError(0.1)) throw new Error('Failed to update candidate');\n    try {\n      const existingCandidate = await db.candidates.get(id);\n      if (!existingCandidate) throw new Error('Candidate not found');\n      const updatedCandidate = {\n        ...existingCandidate,\n        ...updates\n      };\n      await db.candidates.update(id, updatedCandidate);\n      return updatedCandidate;\n    } catch (error) {\n      console.error('Error updating candidate:', error);\n      throw new Error('Failed to update candidate');\n    }\n  },\n  async getCandidateTimeline(candidateId) {\n    await simulateLatency();\n    if (simulateError(0.05)) throw new Error('Failed to fetch candidate timeline');\n    try {\n      const candidate = await db.candidates.get(candidateId);\n      if (!candidate) throw new Error('Candidate not found');\n\n      // Generate timeline from candidate data and notes\n      const timeline = [{\n        id: 'applied',\n        type: 'stage_change',\n        stage: 'applied',\n        timestamp: candidate.appliedDate,\n        description: `Applied for ${candidate.jobTitle || 'the position'}`\n      }, ...(candidate.notes || []).map(note => ({\n        id: note.id,\n        type: 'note',\n        timestamp: note.timestamp,\n        author: note.author,\n        content: note.content\n      }))].sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n      return timeline;\n    } catch (error) {\n      console.error('Error fetching candidate timeline:', error);\n      throw new Error('Failed to fetch candidate timeline');\n    }\n  },\n  // Assessment endpoints\n  async getAssessment(jobId) {\n    await simulateLatency();\n    await initializeDatabase();\n    if (simulateError(0.05)) {\n      // Return null instead of throwing error for non-existent assessments\n      return null;\n    }\n    try {\n      const assessment = await db.assessments.where('jobId').equals(jobId).first();\n      return assessment || null;\n    } catch (error) {\n      console.error('Error fetching assessment:', error);\n      return null;\n    }\n  },\n  async createAssessment(jobId, assessmentData) {\n    await simulateLatency();\n    if (simulateError(0.1)) throw new Error('Failed to create assessment');\n    try {\n      // Remove existing assessment for this job\n      await db.assessments.where('jobId').equals(jobId).delete();\n      const newAssessment = {\n        id: `assessment-${Date.now()}`,\n        jobId,\n        title: assessmentData.title || 'Untitled Assessment',\n        description: assessmentData.description || '',\n        sections: assessmentData.sections || [],\n        ...assessmentData\n      };\n      await db.assessments.add(newAssessment);\n      return newAssessment;\n    } catch (error) {\n      console.error('Error creating assessment:', error);\n      throw new Error('Failed to create assessment');\n    }\n  },\n  async updateAssessment(jobId, assessmentData) {\n    await simulateLatency();\n    if (simulateError(0.1)) throw new Error('Failed to update assessment');\n    try {\n      const existingAssessment = await db.assessments.where('jobId').equals(jobId).first();\n      if (!existingAssessment) {\n        // Create new assessment if it doesn't exist\n        return this.createAssessment(jobId, assessmentData);\n      }\n      const updatedAssessment = {\n        ...existingAssessment,\n        ...assessmentData\n      };\n      await db.assessments.update(existingAssessment.id, updatedAssessment);\n      return updatedAssessment;\n    } catch (error) {\n      console.error('Error updating assessment:', error);\n      throw new Error('Failed to update assessment');\n    }\n  },\n  async submitAssessment(assessmentId, responseData) {\n    await simulateLatency();\n    if (simulateError(0.1)) throw new Error('Failed to submit assessment');\n    try {\n      const newResponse = {\n        id: `response-${Date.now()}`,\n        assessmentId,\n        candidateId: responseData.candidateId || `candidate-${Date.now()}`,\n        responses: responseData.responses || [],\n        submittedAt: new Date()\n      };\n      await db.responses.add(newResponse);\n      return newResponse;\n    } catch (error) {\n      console.error('Error submitting assessment:', error);\n      throw new Error('Failed to submit assessment');\n    }\n  },\n  // Add missing method that was referenced in assessmentsService\n  async saveAssessment(assessment) {\n    return this.updateAssessment(assessment.jobId, assessment);\n  }\n};","map":{"version":3,"names":["db","seedDatabase","API_BASE","simulateLatency","min","max","Promise","resolve","setTimeout","Math","random","simulateError","errorRate","initializeDatabase","jobCount","jobs","count","console","log","error","api","getJobs","params","Error","orderBy","toArray","search","searchLower","toLowerCase","filter","job","_job$company","_job$tags","title","includes","company","tags","some","tag","status","page","pageSize","startIndex","endIndex","paginatedJobs","slice","data","total","length","totalPages","ceil","createJob","jobData","maxOrder","map","j","order","newJob","id","Date","now","createdAt","updatedAt","add","updateJob","updates","existingJob","get","updatedJob","update","reorderJobs","fromOrder","toOrder","fromIndex","findIndex","toIndex","movedJob","splice","transaction","i","success","getCandidates","candidates","candidate","name","email","stage","paginatedCandidates","createCandidate","candidateData","newCandidate","appliedDate","notes","updateCandidate","existingCandidate","updatedCandidate","getCandidateTimeline","candidateId","timeline","type","timestamp","description","jobTitle","note","author","content","sort","a","b","getTime","getAssessment","jobId","assessment","assessments","where","equals","first","createAssessment","assessmentData","delete","newAssessment","sections","updateAssessment","existingAssessment","updatedAssessment","submitAssessment","assessmentId","responseData","newResponse","responses","submittedAt","saveAssessment"],"sources":["C:/Users/Dakshish/talentflow/src/services/api.ts"],"sourcesContent":["import { Job, Candidate, Assessment, AssessmentResponse } from '../types';\r\nimport { db } from './database';\r\nimport { seedDatabase } from '../data/seed';\r\n\r\nconst API_BASE = '/api';\r\n\r\nconst simulateLatency = (min: number = 200, max: number = 1200) => \r\n  new Promise(resolve => setTimeout(resolve, Math.random() * (max - min) + min));\r\n\r\nconst simulateError = (errorRate: number = 0.1) => Math.random() < errorRate;\r\n\r\n// Initialize database with seed data\r\nconst initializeDatabase = async () => {\r\n  try {\r\n    const jobCount = await db.jobs.count();\r\n    if (jobCount === 0) {\r\n      console.log('Initializing database with seed data...');\r\n      await seedDatabase();\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to initialize database:', error);\r\n  }\r\n};\r\n\r\nexport const api = {\r\n  // Jobs endpoints\r\n  async getJobs(params: any = {}) {\r\n    await simulateLatency();\r\n    await initializeDatabase();\r\n    \r\n    if (simulateError(0.05)) throw new Error('Failed to fetch jobs');\r\n    \r\n    try {\r\n      let jobs = await db.jobs.orderBy('order').toArray();\r\n      \r\n      // Apply filters\r\n      if (params.search) {\r\n        const searchLower = params.search.toLowerCase();\r\n        jobs = jobs.filter(job => \r\n          job.title.toLowerCase().includes(searchLower) ||\r\n          job.company?.toLowerCase().includes(searchLower) ||\r\n          job.tags?.some(tag => tag.toLowerCase().includes(searchLower))\r\n        );\r\n      }\r\n      \r\n      if (params.status) {\r\n        jobs = jobs.filter(job => job.status === params.status);\r\n      }\r\n      \r\n      // Apply pagination\r\n      const page = params.page || 1;\r\n      const pageSize = params.pageSize || 10;\r\n      const startIndex = (page - 1) * pageSize;\r\n      const endIndex = startIndex + pageSize;\r\n      const paginatedJobs = jobs.slice(startIndex, endIndex);\r\n      \r\n      return {\r\n        data: paginatedJobs,\r\n        total: jobs.length,\r\n        page,\r\n        pageSize,\r\n        totalPages: Math.ceil(jobs.length / pageSize),\r\n      };\r\n    } catch (error) {\r\n      console.error('Error fetching jobs:', error);\r\n      throw new Error('Failed to fetch jobs');\r\n    }\r\n  },\r\n\r\n  async createJob(jobData: Omit<Job, 'id' | 'createdAt' | 'updatedAt'>) {\r\n    await simulateLatency();\r\n    await initializeDatabase();\r\n    \r\n    if (simulateError(0.1)) throw new Error('Failed to create job');\r\n    \r\n    try {\r\n      // Get the highest order to place new job at the top\r\n      const jobs = await db.jobs.orderBy('order').toArray();\r\n      const maxOrder = jobs.length > 0 ? Math.max(...jobs.map(j => j.order)) : 0;\r\n      \r\n      const newJob: Job = {\r\n        ...jobData,\r\n        id: `job-${Date.now()}`,\r\n        createdAt: new Date(),\r\n        updatedAt: new Date(),\r\n        order: maxOrder + 1,\r\n      };\r\n      \r\n      await db.jobs.add(newJob);\r\n      return newJob;\r\n    } catch (error) {\r\n      console.error('Error creating job:', error);\r\n      throw new Error('Failed to create job');\r\n    }\r\n  },\r\n\r\n  async updateJob(id: string, updates: Partial<Job>) {\r\n    await simulateLatency();\r\n    \r\n    if (simulateError(0.1)) throw new Error('Failed to update job');\r\n    \r\n    try {\r\n      const existingJob = await db.jobs.get(id);\r\n      if (!existingJob) throw new Error('Job not found');\r\n      \r\n      const updatedJob = {\r\n        ...existingJob,\r\n        ...updates,\r\n        updatedAt: new Date(),\r\n      };\r\n      \r\n      await db.jobs.update(id, updatedJob);\r\n      return updatedJob;\r\n    } catch (error) {\r\n      console.error('Error updating job:', error);\r\n      throw new Error('Failed to update job');\r\n    }\r\n  },\r\n\r\n  async reorderJobs(fromOrder: number, toOrder: number) {\r\n    await simulateLatency();\r\n    \r\n    if (simulateError(0.1)) throw new Error('Reorder failed');\r\n    \r\n    try {\r\n      const jobs = await db.jobs.orderBy('order').toArray();\r\n      const fromIndex = jobs.findIndex(job => job.order === fromOrder);\r\n      const toIndex = jobs.findIndex(job => job.order === toOrder);\r\n      \r\n      if (fromIndex === -1 || toIndex === -1) {\r\n        throw new Error('Invalid reorder operation');\r\n      }\r\n      \r\n      const [movedJob] = jobs.splice(fromIndex, 1);\r\n      jobs.splice(toIndex, 0, movedJob);\r\n      \r\n      // Update orders in transaction\r\n      await db.transaction('rw', db.jobs, async () => {\r\n        for (let i = 0; i < jobs.length; i++) {\r\n          await db.jobs.update(jobs[i].id, { order: i + 1 });\r\n        }\r\n      });\r\n      \r\n      return { success: true };\r\n    } catch (error) {\r\n      console.error('Error reordering jobs:', error);\r\n      throw new Error('Failed to reorder jobs');\r\n    }\r\n  },\r\n\r\n  // Candidates endpoints\r\n  async getCandidates(params: any = {}) {\r\n    await simulateLatency();\r\n    await initializeDatabase();\r\n    \r\n    if (simulateError(0.05)) throw new Error('Failed to fetch candidates');\r\n    \r\n    try {\r\n      let candidates = await db.candidates.toArray();\r\n      \r\n      // Apply filters\r\n      if (params.search) {\r\n        const searchLower = params.search.toLowerCase();\r\n        candidates = candidates.filter(candidate => \r\n          candidate.name.toLowerCase().includes(searchLower) ||\r\n          candidate.email.toLowerCase().includes(searchLower)\r\n        );\r\n      }\r\n      \r\n      if (params.stage) {\r\n        candidates = candidates.filter(candidate => candidate.stage === params.stage);\r\n      }\r\n      \r\n      // Apply pagination\r\n      const page = params.page || 1;\r\n      const pageSize = params.pageSize || 50;\r\n      const startIndex = (page - 1) * pageSize;\r\n      const endIndex = startIndex + pageSize;\r\n      const paginatedCandidates = candidates.slice(startIndex, endIndex);\r\n      \r\n      return {\r\n        data: paginatedCandidates,\r\n        total: candidates.length,\r\n        page,\r\n        pageSize,\r\n      };\r\n    } catch (error) {\r\n      console.error('Error fetching candidates:', error);\r\n      throw new Error('Failed to fetch candidates');\r\n    }\r\n  },\r\n\r\n  async createCandidate(candidateData: Omit<Candidate, 'id' | 'appliedDate' | 'notes'>) {\r\n    await simulateLatency();\r\n    \r\n    if (simulateError(0.1)) throw new Error('Failed to create candidate');\r\n    \r\n    try {\r\n      const newCandidate: Candidate = {\r\n        ...candidateData,\r\n        id: `candidate-${Date.now()}`,\r\n        appliedDate: new Date(),\r\n        notes: [],\r\n      };\r\n      \r\n      await db.candidates.add(newCandidate);\r\n      return newCandidate;\r\n    } catch (error) {\r\n      console.error('Error creating candidate:', error);\r\n      throw new Error('Failed to create candidate');\r\n    }\r\n  },\r\n\r\n  async updateCandidate(id: string, updates: Partial<Candidate>) {\r\n    await simulateLatency();\r\n    \r\n    if (simulateError(0.1)) throw new Error('Failed to update candidate');\r\n    \r\n    try {\r\n      const existingCandidate = await db.candidates.get(id);\r\n      if (!existingCandidate) throw new Error('Candidate not found');\r\n      \r\n      const updatedCandidate = {\r\n        ...existingCandidate,\r\n        ...updates,\r\n      };\r\n      \r\n      await db.candidates.update(id, updatedCandidate);\r\n      return updatedCandidate;\r\n    } catch (error) {\r\n      console.error('Error updating candidate:', error);\r\n      throw new Error('Failed to update candidate');\r\n    }\r\n  },\r\n\r\n  async getCandidateTimeline(candidateId: string) {\r\n    await simulateLatency();\r\n    \r\n    if (simulateError(0.05)) throw new Error('Failed to fetch candidate timeline');\r\n    \r\n    try {\r\n      const candidate = await db.candidates.get(candidateId);\r\n      if (!candidate) throw new Error('Candidate not found');\r\n      \r\n      // Generate timeline from candidate data and notes\r\n      const timeline = [\r\n        {\r\n          id: 'applied',\r\n          type: 'stage_change' as const,\r\n          stage: 'applied' as const,\r\n          timestamp: candidate.appliedDate,\r\n          description: `Applied for ${candidate.jobTitle || 'the position'}`,\r\n        },\r\n        ...(candidate.notes || []).map(note => ({\r\n          id: note.id,\r\n          type: 'note' as const,\r\n          timestamp: note.timestamp,\r\n          author: note.author,\r\n          content: note.content,\r\n        })),\r\n      ].sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\r\n      \r\n      return timeline;\r\n    } catch (error) {\r\n      console.error('Error fetching candidate timeline:', error);\r\n      throw new Error('Failed to fetch candidate timeline');\r\n    }\r\n  },\r\n\r\n  // Assessment endpoints\r\n  async getAssessment(jobId: string) {\r\n    await simulateLatency();\r\n    await initializeDatabase();\r\n    \r\n    if (simulateError(0.05)) {\r\n      // Return null instead of throwing error for non-existent assessments\r\n      return null;\r\n    }\r\n    \r\n    try {\r\n      const assessment = await db.assessments.where('jobId').equals(jobId).first();\r\n      return assessment || null;\r\n    } catch (error) {\r\n      console.error('Error fetching assessment:', error);\r\n      return null;\r\n    }\r\n  },\r\n\r\n  async createAssessment(jobId: string, assessmentData: Partial<Assessment>) {\r\n    await simulateLatency();\r\n    \r\n    if (simulateError(0.1)) throw new Error('Failed to create assessment');\r\n    \r\n    try {\r\n      // Remove existing assessment for this job\r\n      await db.assessments.where('jobId').equals(jobId).delete();\r\n      \r\n      const newAssessment: Assessment = {\r\n        id: `assessment-${Date.now()}`,\r\n        jobId,\r\n        title: assessmentData.title || 'Untitled Assessment',\r\n        description: assessmentData.description || '',\r\n        sections: assessmentData.sections || [],\r\n        ...assessmentData,\r\n      };\r\n      \r\n      await db.assessments.add(newAssessment);\r\n      return newAssessment;\r\n    } catch (error) {\r\n      console.error('Error creating assessment:', error);\r\n      throw new Error('Failed to create assessment');\r\n    }\r\n  },\r\n\r\n  async updateAssessment(jobId: string, assessmentData: Partial<Assessment>) {\r\n    await simulateLatency();\r\n    \r\n    if (simulateError(0.1)) throw new Error('Failed to update assessment');\r\n    \r\n    try {\r\n      const existingAssessment = await db.assessments.where('jobId').equals(jobId).first();\r\n      \r\n      if (!existingAssessment) {\r\n        // Create new assessment if it doesn't exist\r\n        return this.createAssessment(jobId, assessmentData);\r\n      }\r\n      \r\n      const updatedAssessment = {\r\n        ...existingAssessment,\r\n        ...assessmentData,\r\n      };\r\n      \r\n      await db.assessments.update(existingAssessment.id, updatedAssessment);\r\n      return updatedAssessment;\r\n    } catch (error) {\r\n      console.error('Error updating assessment:', error);\r\n      throw new Error('Failed to update assessment');\r\n    }\r\n  },\r\n\r\n  async submitAssessment(assessmentId: string, responseData: any) {\r\n    await simulateLatency();\r\n    \r\n    if (simulateError(0.1)) throw new Error('Failed to submit assessment');\r\n    \r\n    try {\r\n      const newResponse: AssessmentResponse = {\r\n        id: `response-${Date.now()}`,\r\n        assessmentId,\r\n        candidateId: responseData.candidateId || `candidate-${Date.now()}`,\r\n        responses: responseData.responses || [],\r\n        submittedAt: new Date(),\r\n      };\r\n      \r\n      await db.responses.add(newResponse);\r\n      return newResponse;\r\n    } catch (error) {\r\n      console.error('Error submitting assessment:', error);\r\n      throw new Error('Failed to submit assessment');\r\n    }\r\n  },\r\n\r\n  // Add missing method that was referenced in assessmentsService\r\n  async saveAssessment(assessment: Assessment) {\r\n    return this.updateAssessment(assessment.jobId, assessment);\r\n  },\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}