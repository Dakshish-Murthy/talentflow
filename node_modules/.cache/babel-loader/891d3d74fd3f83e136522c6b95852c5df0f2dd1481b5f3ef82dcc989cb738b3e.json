{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { api } from '../../services/api';\nconst initialState = {\n  jobs: [],\n  currentJob: null,\n  loading: false,\n  error: null,\n  pagination: {\n    page: 1,\n    pageSize: 10,\n    total: 0,\n    totalPages: 0\n  },\n  filters: {\n    search: '',\n    status: '',\n    tags: []\n  },\n  allJobs: [],\n  hasLoadedAll: false\n};\n\n// Async thunks\nexport const fetchJobs = createAsyncThunk('jobs/fetchJobs', async (params = {}) => {\n  if (params.loadAll) {\n    // Load all jobs at once for client-side pagination\n    const response = await api.getJobs({\n      ...params,\n      pageSize: 1000\n    });\n    return {\n      ...response,\n      loadAll: true\n    };\n  }\n  const response = await api.getJobs(params);\n  return {\n    ...response,\n    loadAll: false\n  };\n});\nexport const createJob = createAsyncThunk('jobs/createJob', async jobData => {\n  const response = await api.createJob(jobData);\n  return response;\n});\nexport const updateJob = createAsyncThunk('jobs/updateJob', async ({\n  id,\n  updates\n}) => {\n  const response = await api.updateJob(id, updates);\n  return response;\n});\nexport const reorderJobs = createAsyncThunk('jobs/reorderJobs', async ({\n  fromOrder,\n  toOrder\n}, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await api.reorderJobs(fromOrder, toOrder);\n    return response;\n  } catch (error) {\n    return rejectWithValue(error);\n  }\n});\nconst jobsSlice = createSlice({\n  name: 'jobs',\n  initialState,\n  reducers: {\n    setFilters: (state, action) => {\n      state.filters = {\n        ...state.filters,\n        ...action.payload\n      };\n      state.pagination.page = 1; // Reset to first page when filters change\n\n      // If we have all jobs loaded, filter locally\n      if (state.hasLoadedAll) {\n        const filteredJobs = filterJobs(state.allJobs, state.filters);\n        state.jobs = paginateJobs(filteredJobs, state.pagination.page, state.pagination.pageSize);\n        state.pagination.total = filteredJobs.length;\n        state.pagination.totalPages = Math.ceil(filteredJobs.length / state.pagination.pageSize);\n      }\n    },\n    setPagination: (state, action) => {\n      const newPagination = {\n        ...state.pagination,\n        ...action.payload\n      };\n      state.pagination = newPagination;\n\n      // If we have all jobs loaded, paginate locally\n      if (state.hasLoadedAll) {\n        const filteredJobs = filterJobs(state.allJobs, state.filters);\n        state.jobs = paginateJobs(filteredJobs, newPagination.page, newPagination.pageSize);\n      }\n    },\n    setCurrentJob: (state, action) => {\n      state.currentJob = action.payload;\n    },\n    clearError: state => {\n      state.error = null;\n    },\n    // Optimistic update for drag and drop\n    optimisticReorder: (state, action) => {\n      const {\n        fromOrder,\n        toOrder\n      } = action.payload;\n      const jobs = [...state.jobs];\n      const fromIndex = jobs.findIndex(job => job.order === fromOrder);\n      const toIndex = jobs.findIndex(job => job.order === toOrder);\n      if (fromIndex !== -1 && toIndex !== -1) {\n        const [movedJob] = jobs.splice(fromIndex, 1);\n        jobs.splice(toIndex, 0, movedJob);\n\n        // Update orders\n        jobs.forEach((job, index) => {\n          job.order = index + 1;\n        });\n        state.jobs = jobs;\n      }\n    },\n    // Rollback for failed reorder\n    rollbackReorder: (state, action) => {\n      state.jobs = action.payload;\n    },\n    // Clear all jobs data\n    clearJobs: state => {\n      state.jobs = [];\n      state.allJobs = [];\n      state.hasLoadedAll = false;\n    }\n  },\n  extraReducers: builder => {\n    builder\n    // Fetch jobs\n    .addCase(fetchJobs.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchJobs.fulfilled, (state, action) => {\n      state.loading = false;\n      if (action.payload.loadAll) {\n        // Store all jobs for client-side operations\n        state.allJobs = action.payload.data;\n        state.hasLoadedAll = true;\n\n        // Apply current filters and pagination\n        const filteredJobs = filterJobs(action.payload.data, state.filters);\n        state.jobs = paginateJobs(filteredJobs, state.pagination.page, state.pagination.pageSize);\n        state.pagination.total = filteredJobs.length;\n        state.pagination.totalPages = Math.ceil(filteredJobs.length / state.pagination.pageSize);\n      } else {\n        // Regular server-side pagination\n        state.jobs = action.payload.data;\n        state.pagination = {\n          ...state.pagination,\n          total: action.payload.total || 0,\n          totalPages: action.payload.totalPages || 0,\n          page: action.payload.page || 1\n        };\n      }\n    }).addCase(fetchJobs.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.error.message || 'Failed to fetch jobs';\n    })\n    // Create job\n    .addCase(createJob.fulfilled, (state, action) => {\n      state.jobs.unshift(action.payload);\n      if (state.hasLoadedAll) {\n        state.allJobs.unshift(action.payload);\n        // Update pagination after adding new job\n        const filteredJobs = filterJobs(state.allJobs, state.filters);\n        state.pagination.total = filteredJobs.length;\n        state.pagination.totalPages = Math.ceil(filteredJobs.length / state.pagination.pageSize);\n      }\n    }).addCase(createJob.rejected, (state, action) => {\n      state.error = action.error.message || 'Failed to create job';\n    })\n    // Update job\n    .addCase(updateJob.fulfilled, (state, action) => {\n      var _state$currentJob;\n      const index = state.jobs.findIndex(job => job.id === action.payload.id);\n      if (index !== -1) {\n        state.jobs[index] = action.payload;\n      }\n      if (state.hasLoadedAll) {\n        const allIndex = state.allJobs.findIndex(job => job.id === action.payload.id);\n        if (allIndex !== -1) {\n          state.allJobs[allIndex] = action.payload;\n        }\n        // Update pagination after updating job\n        const filteredJobs = filterJobs(state.allJobs, state.filters);\n        state.pagination.total = filteredJobs.length;\n        state.pagination.totalPages = Math.ceil(filteredJobs.length / state.pagination.pageSize);\n      }\n      if (((_state$currentJob = state.currentJob) === null || _state$currentJob === void 0 ? void 0 : _state$currentJob.id) === action.payload.id) {\n        state.currentJob = action.payload;\n      }\n    })\n    // Reorder jobs\n    .addCase(reorderJobs.rejected, (state, action) => {\n      state.error = 'Failed to reorder jobs. Please try again.';\n    });\n  }\n});\n\n// Helper functions for client-side operations\nconst filterJobs = (jobs, filters) => {\n  let filtered = [...jobs];\n  if (filters.search) {\n    const searchLower = filters.search.toLowerCase();\n    filtered = filtered.filter(job => {\n      var _job$tags;\n      return job.title.toLowerCase().includes(searchLower) || ((_job$tags = job.tags) === null || _job$tags === void 0 ? void 0 : _job$tags.some(tag => tag.toLowerCase().includes(searchLower)));\n    });\n  }\n  if (filters.status) {\n    filtered = filtered.filter(job => job.status === filters.status);\n  }\n  if (filters.tags.length > 0) {\n    filtered = filtered.filter(job => filters.tags.some(tag => {\n      var _job$tags2;\n      return (_job$tags2 = job.tags) === null || _job$tags2 === void 0 ? void 0 : _job$tags2.includes(tag);\n    }));\n  }\n  return filtered;\n};\nconst paginateJobs = (jobs, page, pageSize) => {\n  const startIndex = (page - 1) * pageSize;\n  const endIndex = startIndex + pageSize;\n  return jobs.slice(startIndex, endIndex);\n};\nexport const {\n  setFilters,\n  setPagination,\n  setCurrentJob,\n  clearError,\n  optimisticReorder,\n  rollbackReorder,\n  clearJobs\n} = jobsSlice.actions;\nexport default jobsSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","api","initialState","jobs","currentJob","loading","error","pagination","page","pageSize","total","totalPages","filters","search","status","tags","allJobs","hasLoadedAll","fetchJobs","params","loadAll","response","getJobs","createJob","jobData","updateJob","id","updates","reorderJobs","fromOrder","toOrder","rejectWithValue","jobsSlice","name","reducers","setFilters","state","action","payload","filteredJobs","filterJobs","paginateJobs","length","Math","ceil","setPagination","newPagination","setCurrentJob","clearError","optimisticReorder","fromIndex","findIndex","job","order","toIndex","movedJob","splice","forEach","index","rollbackReorder","clearJobs","extraReducers","builder","addCase","pending","fulfilled","data","rejected","message","unshift","_state$currentJob","allIndex","filtered","searchLower","toLowerCase","filter","_job$tags","title","includes","some","tag","_job$tags2","startIndex","endIndex","slice","actions","reducer"],"sources":["C:/Users/Dakshish/talentflow/src/store/slices/jobsSlice.ts"],"sourcesContent":["import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';\r\nimport { Job } from '../../types';\r\nimport { api } from '../../services/api';\r\n\r\ninterface JobsState {\r\n  jobs: Job[];\r\n  currentJob: Job | null;\r\n  loading: boolean;\r\n  error: string | null;\r\n  pagination: {\r\n    page: number;\r\n    pageSize: number;\r\n    total: number;\r\n    totalPages: number;\r\n  };\r\n  filters: {\r\n    search: string;\r\n    status: string;\r\n    tags: string[];\r\n  };\r\n  // Add local state for better performance\r\n  allJobs: Job[];\r\n  hasLoadedAll: boolean;\r\n}\r\n\r\nconst initialState: JobsState = {\r\n  jobs: [],\r\n  currentJob: null,\r\n  loading: false,\r\n  error: null,\r\n  pagination: {\r\n    page: 1,\r\n    pageSize: 10,\r\n    total: 0,\r\n    totalPages: 0,\r\n  },\r\n  filters: {\r\n    search: '',\r\n    status: '',\r\n    tags: [],\r\n  },\r\n  allJobs: [],\r\n  hasLoadedAll: false,\r\n};\r\n\r\n// Async thunks\r\nexport const fetchJobs = createAsyncThunk(\r\n  'jobs/fetchJobs',\r\n  async (params: { page?: number; pageSize?: number; search?: string; status?: string; loadAll?: boolean } = {}) => {\r\n    if (params.loadAll) {\r\n      // Load all jobs at once for client-side pagination\r\n      const response = await api.getJobs({ ...params, pageSize: 1000 });\r\n      return { ...response, loadAll: true };\r\n    }\r\n    \r\n    const response = await api.getJobs(params);\r\n    return { ...response, loadAll: false };\r\n  }\r\n);\r\n\r\nexport const createJob = createAsyncThunk(\r\n  'jobs/createJob',\r\n  async (jobData: Omit<Job, 'id' | 'createdAt' | 'updatedAt'>) => {\r\n    const response = await api.createJob(jobData);\r\n    return response;\r\n  }\r\n);\r\n\r\nexport const updateJob = createAsyncThunk(\r\n  'jobs/updateJob',\r\n  async ({ id, updates }: { id: string; updates: Partial<Job> }) => {\r\n    const response = await api.updateJob(id, updates);\r\n    return response;\r\n  }\r\n);\r\n\r\nexport const reorderJobs = createAsyncThunk(\r\n  'jobs/reorderJobs',\r\n  async ({ fromOrder, toOrder }: { fromOrder: number; toOrder: number }, { rejectWithValue }) => {\r\n    try {\r\n      const response = await api.reorderJobs(fromOrder, toOrder);\r\n      return response;\r\n    } catch (error) {\r\n      return rejectWithValue(error);\r\n    }\r\n  }\r\n);\r\n\r\nconst jobsSlice = createSlice({\r\n  name: 'jobs',\r\n  initialState,\r\n  reducers: {\r\n    setFilters: (state, action: PayloadAction<Partial<JobsState['filters']>>) => {\r\n      state.filters = { ...state.filters, ...action.payload };\r\n      state.pagination.page = 1; // Reset to first page when filters change\r\n      \r\n      // If we have all jobs loaded, filter locally\r\n      if (state.hasLoadedAll) {\r\n        const filteredJobs = filterJobs(state.allJobs, state.filters);\r\n        state.jobs = paginateJobs(filteredJobs, state.pagination.page, state.pagination.pageSize);\r\n        state.pagination.total = filteredJobs.length;\r\n        state.pagination.totalPages = Math.ceil(filteredJobs.length / state.pagination.pageSize);\r\n      }\r\n    },\r\n    setPagination: (state, action: PayloadAction<Partial<JobsState['pagination']>>) => {\r\n      const newPagination = { ...state.pagination, ...action.payload };\r\n      state.pagination = newPagination;\r\n      \r\n      // If we have all jobs loaded, paginate locally\r\n      if (state.hasLoadedAll) {\r\n        const filteredJobs = filterJobs(state.allJobs, state.filters);\r\n        state.jobs = paginateJobs(filteredJobs, newPagination.page, newPagination.pageSize);\r\n      }\r\n    },\r\n    setCurrentJob: (state, action: PayloadAction<Job | null>) => {\r\n      state.currentJob = action.payload;\r\n    },\r\n    clearError: (state) => {\r\n      state.error = null;\r\n    },\r\n    // Optimistic update for drag and drop\r\n    optimisticReorder: (state, action: PayloadAction<{ fromOrder: number; toOrder: number }>) => {\r\n      const { fromOrder, toOrder } = action.payload;\r\n      const jobs = [...state.jobs];\r\n      \r\n      const fromIndex = jobs.findIndex(job => job.order === fromOrder);\r\n      const toIndex = jobs.findIndex(job => job.order === toOrder);\r\n      \r\n      if (fromIndex !== -1 && toIndex !== -1) {\r\n        const [movedJob] = jobs.splice(fromIndex, 1);\r\n        jobs.splice(toIndex, 0, movedJob);\r\n        \r\n        // Update orders\r\n        jobs.forEach((job, index) => {\r\n          job.order = index + 1;\r\n        });\r\n        \r\n        state.jobs = jobs;\r\n      }\r\n    },\r\n    // Rollback for failed reorder\r\n    rollbackReorder: (state, action: PayloadAction<Job[]>) => {\r\n      state.jobs = action.payload;\r\n    },\r\n    // Clear all jobs data\r\n    clearJobs: (state) => {\r\n      state.jobs = [];\r\n      state.allJobs = [];\r\n      state.hasLoadedAll = false;\r\n    },\r\n  },\r\n  extraReducers: (builder) => {\r\n    builder\r\n      // Fetch jobs\r\n      .addCase(fetchJobs.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchJobs.fulfilled, (state, action) => {\r\n        state.loading = false;\r\n        \r\n        if (action.payload.loadAll) {\r\n          // Store all jobs for client-side operations\r\n          state.allJobs = action.payload.data;\r\n          state.hasLoadedAll = true;\r\n          \r\n          // Apply current filters and pagination\r\n          const filteredJobs = filterJobs(action.payload.data, state.filters);\r\n          state.jobs = paginateJobs(filteredJobs, state.pagination.page, state.pagination.pageSize);\r\n          state.pagination.total = filteredJobs.length;\r\n          state.pagination.totalPages = Math.ceil(filteredJobs.length / state.pagination.pageSize);\r\n        } else {\r\n          // Regular server-side pagination\r\n          state.jobs = action.payload.data;\r\n          state.pagination = {\r\n            ...state.pagination,\r\n            total: action.payload.total || 0,\r\n            totalPages: action.payload.totalPages || 0,\r\n            page: action.payload.page || 1,\r\n          };\r\n        }\r\n      })\r\n      .addCase(fetchJobs.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.error.message || 'Failed to fetch jobs';\r\n      })\r\n      // Create job\r\n      .addCase(createJob.fulfilled, (state, action) => {\r\n        state.jobs.unshift(action.payload);\r\n        if (state.hasLoadedAll) {\r\n          state.allJobs.unshift(action.payload);\r\n          // Update pagination after adding new job\r\n          const filteredJobs = filterJobs(state.allJobs, state.filters);\r\n          state.pagination.total = filteredJobs.length;\r\n          state.pagination.totalPages = Math.ceil(filteredJobs.length / state.pagination.pageSize);\r\n        }\r\n      })\r\n      .addCase(createJob.rejected, (state, action) => {\r\n        state.error = action.error.message || 'Failed to create job';\r\n      })\r\n      // Update job\r\n      .addCase(updateJob.fulfilled, (state, action) => {\r\n        const index = state.jobs.findIndex(job => job.id === action.payload.id);\r\n        if (index !== -1) {\r\n          state.jobs[index] = action.payload;\r\n        }\r\n        \r\n        if (state.hasLoadedAll) {\r\n          const allIndex = state.allJobs.findIndex(job => job.id === action.payload.id);\r\n          if (allIndex !== -1) {\r\n            state.allJobs[allIndex] = action.payload;\r\n          }\r\n          // Update pagination after updating job\r\n          const filteredJobs = filterJobs(state.allJobs, state.filters);\r\n          state.pagination.total = filteredJobs.length;\r\n          state.pagination.totalPages = Math.ceil(filteredJobs.length / state.pagination.pageSize);\r\n        }\r\n        \r\n        if (state.currentJob?.id === action.payload.id) {\r\n          state.currentJob = action.payload;\r\n        }\r\n      })\r\n      // Reorder jobs\r\n      .addCase(reorderJobs.rejected, (state, action) => {\r\n        state.error = 'Failed to reorder jobs. Please try again.';\r\n      });\r\n  },\r\n});\r\n\r\n// Helper functions for client-side operations\r\nconst filterJobs = (jobs: Job[], filters: JobsState['filters']) => {\r\n  let filtered = [...jobs];\r\n  \r\n  if (filters.search) {\r\n    const searchLower = filters.search.toLowerCase();\r\n    filtered = filtered.filter(job => \r\n      job.title.toLowerCase().includes(searchLower) ||\r\n      job.tags?.some(tag => tag.toLowerCase().includes(searchLower))\r\n    );\r\n  }\r\n  \r\n  if (filters.status) {\r\n    filtered = filtered.filter(job => job.status === filters.status);\r\n  }\r\n  \r\n  if (filters.tags.length > 0) {\r\n    filtered = filtered.filter(job => \r\n      filters.tags.some(tag => job.tags?.includes(tag))\r\n    );\r\n  }\r\n  \r\n  return filtered;\r\n};\r\n\r\nconst paginateJobs = (jobs: Job[], page: number, pageSize: number) => {\r\n  const startIndex = (page - 1) * pageSize;\r\n  const endIndex = startIndex + pageSize;\r\n  return jobs.slice(startIndex, endIndex);\r\n};\r\n\r\nexport const {\r\n  setFilters,\r\n  setPagination,\r\n  setCurrentJob,\r\n  clearError,\r\n  optimisticReorder,\r\n  rollbackReorder,\r\n  clearJobs,\r\n} = jobsSlice.actions;\r\n\r\nexport default jobsSlice.reducer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}